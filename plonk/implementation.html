<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementation - docs</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> FFT Library</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../fft/benchmarks.html"><strong aria-hidden="true">2.1.</strong> Benchmarks</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Plonk</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../plonk/recap.html"><strong aria-hidden="true">3.1.</strong> Recap</a></li><li class="chapter-item expanded "><a href="../plonk/protocol.html"><strong aria-hidden="true">3.2.</strong> Protocol</a></li><li class="chapter-item expanded "><a href="../plonk/implementation.html" class="active"><strong aria-hidden="true">3.3.</strong> Implementation</a></li><li class="chapter-item expanded "><a href="../plonk/constraint_system.html"><strong aria-hidden="true">3.4.</strong> Circuit API</a></li></ol></li><li class="chapter-item expanded "><a href="../starks/starks.html"><strong aria-hidden="true">4.</strong> STARKs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../starks/recap.html"><strong aria-hidden="true">4.1.</strong> Recap</a></li><li class="chapter-item expanded "><a href="../starks/protocol_overview.html"><strong aria-hidden="true">4.2.</strong> Protocol overview</a></li><li class="chapter-item expanded "><a href="../starks/protocol.html"><strong aria-hidden="true">4.3.</strong> Protocol</a></li><li class="chapter-item expanded "><a href="../starks/implementation.html"><strong aria-hidden="true">4.4.</strong> Implementation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../starks/api.html"><strong aria-hidden="true">4.4.1.</strong> High Level API</a></li><li class="chapter-item expanded "><a href="../starks/under_the_hood.html"><strong aria-hidden="true">4.4.2.</strong> Under the hood</a></li></ol></li><li class="chapter-item expanded "><a href="../starks/stone_prover/introduction.html"><strong aria-hidden="true">4.5.</strong> Stone prover</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../starks/stone_prover/trace_plain_layout.html"><strong aria-hidden="true">4.5.1.</strong> Plain layout trace description</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../starks/cairo.html"><strong aria-hidden="true">5.</strong> Cairo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../starks/cairo_trace_succinct.html"><strong aria-hidden="true">5.1.</strong> Trace Formal Description</a></li><li class="chapter-item expanded "><a href="../starks/cairo_trace_descriptive.html"><strong aria-hidden="true">5.2.</strong> Trace Detailed Description</a></li><li class="chapter-item expanded "><a href="../starks/cairo_rap.html"><strong aria-hidden="true">5.3.</strong> RAP</a></li><li class="chapter-item expanded "><a href="../starks/virtual_cols.html"><strong aria-hidden="true">5.4.</strong> Virtual Columns</a></li><li class="chapter-item expanded "><a href="../starks/builtins.html"><strong aria-hidden="true">5.5.</strong> Built-ins</a></li><li class="chapter-item expanded "><a href="../starks/cairo_cli.html"><strong aria-hidden="true">5.6.</strong> CLI</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">docs</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<p>In this section we discuss the implementation details of the PLONK algorithm. We use the notation and terminology of the <a href="./protocol.html">protocol</a> and <a href="./recap.html">recap</a> sections. </p>
<p>At the moment our API supports the backend of PLONK, that is, all the setup, prove and verify algorithms. We temporarily rely on external sources for the definition of a circuit and the creation of the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> matrices, as well as the execution of it to obtain the trace matrix <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>. We mainly use gnark temporarily for that purpose.</p>
<p>To generate proofs and validate them, we need to feed the algorithms with precomputed values of the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> matrices, and the primitive root of unity <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span>.</p>
<p>Let's see our API on a test circuit that provides all these values. The program in this case is the one that takes an input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, a private input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> and computes <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>. As in the toy example of the recap, the output of the program is added to the public inputs and the circuit actually asserts that the output is the claimed value. So more precisely, the prover will generate a proof for the statement <code>ASSERT(x*e+5==y)</code>, where both <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> are public inputs.</p>
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>Here is the happy path.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is the common preprocessed input for
// the test circuit ( ASSERT(x * e + 5 == y) )
let common_preprocessed_input = test_common_preprocessed_input_2();

// Input
let x = FieldElement::from(2_u64);

// Private input
let e = FieldElement::from(3_u64);

let y, witness = test_witness_2(x, e);

let srs = test_srs(common_preprocessed_input.n);
let kzg = KZG::new(srs);

let verifying_key = setup(&amp;common_preprocessed_input, &amp;kzg);

let random_generator = TestRandomFieldGenerator {};
let prover = Prover::new(kzg.clone(), random_generator);

let public_input = vec![x.clone(), y];

let proof = prover.prove(
    &amp;witness,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key,
);

let verifier = Verifier::new(kzg);
assert!(verifier.verify(
    &amp;proof,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key
));
<span class="boring">}
</span></code></pre></pre>
<p>Let's brake it down. The helper function <code>test_common_preprocessed_input_2()</code> returns an instance of the following struct for the particular test circuit:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CommonPreprocessedInput&lt;F: IsField&gt; {
    pub n: usize,
    pub domain: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub omega: FieldElement&lt;F&gt;,
    pub k1: FieldElement&lt;F&gt;,

    pub ql: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qr: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qo: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qm: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub qc: Polynomial&lt;FieldElement&lt;F&gt;&gt;,

    pub s1: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub s2: Polynomial&lt;FieldElement&lt;F&gt;&gt;,
    pub s3: Polynomial&lt;FieldElement&lt;F&gt;&gt;,

    pub s1_lagrange: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub s2_lagrange: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub s3_lagrange: Vec&lt;FieldElement&lt;F&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Apart from the eight polynomials in the canonical basis, we store also here the number of constraints <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, the domain <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>, the primitive <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-th of unity <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> and the element <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. The element <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> will be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span>. For convenience, we also store the polynomials <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">σi</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in Lagrange form.</p>
<p>The following lines define the particular values of the program input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and the private input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Input
let x = FieldElement::from(2_u64);

// Private input
let e = FieldElement::from(3_u64);
let y, witness = test_witness_2(x, e);
<span class="boring">}
</span></code></pre></pre>
<p>The function <code>test_witness_2(x, e)</code> returns an instance of the following struct, that holds the polynomials that interpolate the columns <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> of the trace matrix <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Witness&lt;F: IsField&gt; {
    pub a: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub b: Vec&lt;FieldElement&lt;F&gt;&gt;,
    pub c: Vec&lt;FieldElement&lt;F&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Next the commitment scheme KZG (Kate-Zaverucha-Goldberg) is instantiated.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let srs = test_srs(common_preprocessed_input.n);
let kzg = KZG::new(srs);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>setup</code> function performs the setup phase. It only needs the common preprocessed input and the commitment scheme.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let verifying_key = setup(&amp;common_preprocessed_input, &amp;kzg);
<span class="boring">}
</span></code></pre></pre>
<p>It outputs an instance of the struct <code>VerificationKey</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VerificationKey&lt;G1Point&gt; {
    pub qm_1: G1Point,
    pub ql_1: G1Point,
    pub qr_1: G1Point,
    pub qo_1: G1Point,
    pub qc_1: G1Point,

    pub s1_1: G1Point,
    pub s2_1: G1Point,
    pub s3_1: G1Point,
}
<span class="boring">}
</span></code></pre></pre>
<p>It stores the commitments of the eight polynomials of the common preprocessed input. The suffix <code>_1</code> means it is a commitment. It comes from the notation <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is a polynomial.</p>
<p>Then a prover is instantiated</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let random_generator = TestRandomFieldGenerator {};
let prover = Prover::new(kzg.clone(), random_generator);
<span class="boring">}
</span></code></pre></pre>
<p>The prover is an instance of the struct <code>Prover</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prover&lt;F, CS, R&gt;
where
  F:  IsField,
  CS: IsCommitmentScheme&lt;F&gt;,
  R:  IsRandomFieldElementGenerator&lt;F&gt;
  {
    commitment_scheme: CS,
    random_generator: R,
    phantom: PhantomData&lt;F&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>It stores an instance of a commitment scheme and a random field element generator needed for blinding polynomials.</p>
<p>Then the public input is defined. As we mentioned in the recap, the public input contains the output of the program.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let public_input = vec![x.clone(), y];
<span class="boring">}
</span></code></pre></pre>
<p>We then generate a proof using the prover's method <code>prove</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let proof = prover.prove(
    &amp;witness,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key,
);
<span class="boring">}
</span></code></pre></pre>
<p>The output is an instance of the struct <code>Proof</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Proof&lt;F: IsField, CS: IsCommitmentScheme&lt;F&gt;&gt; {
    // Round 1.
    /// Commitment to the wire polynomial `a(x)`
    pub a_1: CS::Commitment,
    /// Commitment to the wire polynomial `b(x)`
    pub b_1: CS::Commitment,
    /// Commitment to the wire polynomial `c(x)`
    pub c_1: CS::Commitment,

    // Round 2.
    /// Commitment to the copy constraints polynomial `z(x)`
    pub z_1: CS::Commitment,

    // Round 3.
    /// Commitment to the low part of the quotient polynomial t(X)
    pub t_lo_1: CS::Commitment,
    /// Commitment to the middle part of the quotient polynomial t(X)
    pub t_mid_1: CS::Commitment,
    /// Commitment to the high part of the quotient polynomial t(X)
    pub t_hi_1: CS::Commitment,

    // Round 4.
    /// Value of `a(ζ)`.
    pub a_zeta: FieldElement&lt;F&gt;,
    /// Value of `b(ζ)`.
    pub b_zeta: FieldElement&lt;F&gt;,
    /// Value of `c(ζ)`.
    pub c_zeta: FieldElement&lt;F&gt;,
    /// Value of `S_σ1(ζ)`.
    pub s1_zeta: FieldElement&lt;F&gt;,
    /// Value of `S_σ2(ζ)`.
    pub s2_zeta: FieldElement&lt;F&gt;,
    /// Value of `z(ζω)`.
    pub z_zeta_omega: FieldElement&lt;F&gt;,

    // Round 5
    /// Value of `p_non_constant(ζ)`.
    pub p_non_constant_zeta: FieldElement&lt;F&gt;,
    ///  Value of `t(ζ)`.
    pub t_zeta: FieldElement&lt;F&gt;,
    /// Batch opening proof for all the evaluations at ζ
    pub w_zeta_1: CS::Commitment,
    /// Single opening proof for `z(ζω)`.
    pub w_zeta_omega_1: CS::Commitment,
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we instantiate a verifier.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let verifier = Verifier::new(kzg);
<span class="boring">}
</span></code></pre></pre>
<p>It's an instance of <code>Verifier</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Verifier&lt;F: IsField, CS: IsCommitmentScheme&lt;F&gt;&gt; {
    commitment_scheme: CS,
    phantom: PhantomData&lt;F&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we call the verifier's method <code>verify</code> that outputs a <code>bool</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(verifier.verify(
    &amp;proof,
    &amp;public_input,
    &amp;common_preprocessed_input,
    &amp;verifying_key
));
<span class="boring">}
</span></code></pre></pre>
<h2 id="padding"><a class="header" href="#padding">Padding</a></h2>
<p>All the matrices <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> are padded with dummy rows so that their length is a power of two. To be able to interpolate their columns, we need a primitive root of unity <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> of that order. Given the particular field used in our implementation, that means that the maximum possible size for a circuit is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>The entries of the dummy rows are filled in with zeroes in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> matrices. The <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> matrix needs to be consistent with the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> matrix. Therefore it is filled with the value of the variable with index <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</p>
<p>Some other rows in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> matrix have also dummy values. These are the rows corresponding to the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> columns of the public input rows. In the recap we denoted them with the empty <code>-</code> symbol. They are filled in with the same logic as the padding rows, as well as the corresponding values in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> matrix.</p>
<h1 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h1>
<p>The implementation pretty much follows the rounds as are described in the <a href="./protocol.html">protocol</a> section. There are a few details that are worth mentioning.</p>
<h2 id="commitment-scheme"><a class="header" href="#commitment-scheme">Commitment Scheme</a></h2>
<p>The commitment scheme we use is the <a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">Kate-Zaverucha-Goldberg</a> scheme with the <code>BLS 12 381</code> curve and the ate pairing. It can be found in the <code>commitments</code> module of the <code>lambdaworks_crypto</code> package.</p>
<p>The order <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> of the cyclic subgroup is</p>
<pre><code>0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
</code></pre>
<p>The maximum power of two that divides <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>. Therefore, that is the maximum possible order for a primitive root of unity in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> with order a power of two. </p>
<h2 id="fiat-shamir"><a class="header" href="#fiat-shamir">Fiat-Shamir</a></h2>
<h3 id="transcript-strategy"><a class="header" href="#transcript-strategy">Transcript strategy</a></h3>
<p>Here we describe our implementation of the transcript used for the Fiat-Shamir heuristic.</p>
<p>A <code>Transcript</code> exposes two methods: <code>append</code> and <code>challenge</code>.</p>
<p>The method <code>append</code> adds a message to the transcript by updating the internal state of the hasher with the raw bytes of the message. </p>
<p>The  method <code>challenge</code> returns the result of the hasher using the current internal state of the hasher. It subsequently resets the hasher and updates the internal state with the last result.</p>
<p>Here is an example of this process:</p>
<ol>
<li>Start a fresh transcript. </li>
<li>Call <code>append</code> and pass <code>message_1</code>.</li>
<li>Call <code>append</code> and pass <code>message_2</code>.</li>
<li>The internal state of the hasher at this point is <code>message_2 || message_1</code>.</li>
<li>Call <code>challenge</code>. The output is <code>Hash(message_2 || message_1)</code>.</li>
<li>Call <code>append</code> and pass <code>message_3</code>.</li>
<li>Call <code>challenge</code>. The output is <code>Hash(message_3 || Hash(message_2 || message_1))</code>.</li>
<li>Call <code>append</code> and pass <code>message_4</code>.</li>
</ol>
<p>The internal state of the hasher at the end of this exercise is <code>message_4 || Hash(message_3 || Hash(message_2 || message_1))</code></p>
<p>The underlying hasher function we use is <code>h=sha3</code>.</p>
<h3 id="field-elements"><a class="header" href="#field-elements">Field elements</a></h3>
<p>The result of every challenge is a <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span>-bit string, which is interpreted as an integer in big-endian order. A field element is constructed out of it by taking modulo the field order. The prime field used in this implementation has a <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">255</span></span></span></span>-bit order. Therefore some field elements are more probable to occur than others because they have more representatives as 256-bit integers.</p>
<h3 id="strong-fiat-shamir"><a class="header" href="#strong-fiat-shamir">Strong Fiat-Shamir</a></h3>
<p>The first messages added to the transcript are all commitments of the polynomials of the common preprocessed input and the values of the public inputs. This prevents a known vulnerability called &quot;weak Fiat-Shamir&quot;.
Check out the following resources to learn more about it.</p>
<ul>
<li><a href="https://www.zkdocs.com/docs/zkdocs/protocol-primitives/fiat-shamir/#what-can-go-wrong">What can go wrong (zkdocs)</a></li>
<li><a href="https://eprint.iacr.org/2016/771.pdf">How not to Prove Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios</a></li>
<li><a href="https://eprint.iacr.org/2023/691">Weak Fiat-Shamir Attacks on Modern Proof Systems</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../plonk/protocol.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../plonk/constraint_system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../plonk/protocol.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../plonk/constraint_system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
